name: "GEO Audit â€” AI-Readiness Score"
description: "Audit any website's AI-readiness score. 20 rules, 0-100 score, A-F grade with PR comments."
author: "GLINCKER"

branding:
  icon: search
  color: green

inputs:
  url:
    description: "URL to audit (e.g. https://example.com)"
    required: true
  fail-under:
    description: "Minimum score threshold â€” fail the step if score is below this value (0 = never fail)"
    required: false
    default: "0"
  api-key:
    description: "GeoKit Cloud API key (optional) â€” enables cloud mode with history tracking and team visibility"
    required: false
  api-url:
    description: "GeoKit Cloud API URL (defaults to production)"
    required: false
    default: "https://api.geokit.dev"
  comment:
    description: "Post score as a PR comment (requires pull_request trigger and write permissions)"
    required: false
    default: "false"
  badge:
    description: "Include badge markdown snippet in the output"
    required: false
    default: "false"
  timeout:
    description: "Fetch timeout in milliseconds"
    required: false
    default: "15000"
  version:
    description: "Specific @glincker/geo-audit version to use (local mode only, default: latest)"
    required: false
    default: "latest"

outputs:
  score:
    description: "Numeric score (0-100)"
    value: ${{ steps.audit.outputs.score }}
  grade:
    description: "Letter grade (A, B, C, D, or F)"
    value: ${{ steps.audit.outputs.grade }}
  badge:
    description: "Static shields.io badge URL for this score"
    value: ${{ steps.audit.outputs.badge }}
  result:
    description: "Full JSON audit result"
    value: ${{ steps.audit.outputs.result }}

runs:
  using: composite
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: "20"

    - name: Run GEO Audit
      id: audit
      shell: bash
      env:
        INPUT_URL: ${{ inputs.url }}
        INPUT_API_KEY: ${{ inputs.api-key }}
        INPUT_API_URL: ${{ inputs.api-url }}
        INPUT_TIMEOUT: ${{ inputs.timeout }}
        INPUT_VERSION: ${{ inputs.version }}
        INPUT_FAIL_UNDER: ${{ inputs.fail-under }}
        INPUT_BADGE: ${{ inputs.badge }}
        GITHUB_CONTEXT: ${{ toJSON(github) }}
      run: |
        set -euo pipefail

        # â”€â”€â”€ CLOUD MODE (API key provided) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if [ -n "${INPUT_API_KEY}" ]; then
          echo "ðŸŒ©ï¸  Running in Cloud Mode (with API key)"

          # Build metadata payload with GitHub context
          METADATA=$(node -e "
            const ctx = ${GITHUB_CONTEXT};
            const meta = {
              repo: ctx.repository || null,
              branch: ctx.ref?.replace('refs/heads/', '') || null,
              commit: ctx.sha || null,
              pr: ctx.event?.pull_request?.number || null,
              actor: ctx.actor || null,
              workflow: ctx.workflow || null,
            };
            console.log(JSON.stringify(meta));
          ")

          # Call GeoKit Cloud API
          RESPONSE=$(curl -s -X POST "${INPUT_API_URL}/api/audits/ci" \
            -H "Authorization: Bearer ${INPUT_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "{
              \"url\": \"${INPUT_URL}\",
              \"failUnder\": ${INPUT_FAIL_UNDER},
              \"metadata\": ${METADATA}
            }" 2>/dev/null) || {
            echo "::error::Failed to reach GeoKit Cloud API at ${INPUT_API_URL}"
            exit 1
          }

          # Parse cloud response
          SCORE=$(echo "$RESPONSE" | node -e "
            const d = require('fs').readFileSync('/dev/stdin','utf8');
            try { const j = JSON.parse(d); console.log(j.score ?? '-1'); }
            catch { console.log('-1'); }
          ")
          GRADE=$(echo "$RESPONSE" | node -e "
            const d = require('fs').readFileSync('/dev/stdin','utf8');
            try { const j = JSON.parse(d); console.log(j.grade ?? '?'); }
            catch { console.log('?'); }
          ")
          PASS=$(echo "$RESPONSE" | node -e "
            const d = require('fs').readFileSync('/dev/stdin','utf8');
            try { const j = JSON.parse(d); console.log(j.pass ? 'true' : 'false'); }
            catch { console.log('false'); }
          ")
          AUDIT_ID=$(echo "$RESPONSE" | node -e "
            const d = require('fs').readFileSync('/dev/stdin','utf8');
            try { const j = JSON.parse(d); console.log(j.auditId || ''); }
            catch { console.log(''); }
          ")

          # Handle API errors
          if [ "$SCORE" = "-1" ] || [ "$GRADE" = "?" ]; then
            ERROR_MSG=$(echo "$RESPONSE" | node -e "
              const d = require('fs').readFileSync('/dev/stdin','utf8');
              try { const j = JSON.parse(d); console.log(j.error || 'Unknown error'); }
              catch { console.log('Failed to parse response'); }
            ")
            echo "::error::GeoKit Cloud API error: ${ERROR_MSG}"
            exit 1
          fi

          # Build RESULT for downstream compatibility
          RESULT=$(echo "$RESPONSE" | node -e "
            const d = require('fs').readFileSync('/dev/stdin','utf8');
            const apiResp = JSON.parse(d);
            // Convert cloud response to local format for compatibility
            const result = {
              score: apiResp.score,
              grade: apiResp.grade,
              recommendations: apiResp.failedRules?.map(r => ({
                message: r.description,
                impact: r.impact || 0
              })) || []
            };
            console.log(JSON.stringify(result));
          ")

          echo "âœ… Cloud audit complete (Audit ID: ${AUDIT_ID})"

        # â”€â”€â”€ LOCAL MODE (no API key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        else
          echo "ðŸ–¥ï¸  Running in Local Mode (no API key)"

          # Install and run audit locally
          RESULT=$(npx --yes "@glincker/geo-audit@${INPUT_VERSION}" "${INPUT_URL}" --json --timeout "${INPUT_TIMEOUT}" 2>/dev/null) || {
            echo "::error::Failed to audit ${INPUT_URL}. Check the URL is accessible."
            exit 1
          }

          # Parse score and grade safely
          SCORE=$(echo "$RESULT" | node -e "
            const d = require('fs').readFileSync('/dev/stdin','utf8');
            try { console.log(JSON.parse(d).score); }
            catch { console.log('-1'); }
          ")
          GRADE=$(echo "$RESULT" | node -e "
            const d = require('fs').readFileSync('/dev/stdin','utf8');
            try { console.log(JSON.parse(d).grade); }
            catch { console.log('?'); }
          ")
        fi

        if [ "$SCORE" = "-1" ] || [ "$GRADE" = "?" ]; then
          echo "::error::Failed to parse audit result for ${INPUT_URL}"
          exit 1
        fi

        # Grade â†’ color mapping
        case "$GRADE" in
          A) COLOR="brightgreen"; EMOJI="ðŸŸ¢" ;;
          B) COLOR="green";       EMOJI="ðŸŸ¢" ;;
          C) COLOR="yellow";      EMOJI="ðŸŸ¡" ;;
          D) COLOR="orange";      EMOJI="ðŸŸ " ;;
          *)  COLOR="red";         EMOJI="ðŸ”´" ;;
        esac

        # Build static badge URL
        BADGE_URL="https://img.shields.io/badge/AI--Ready-${SCORE}%20(${GRADE})-${COLOR}"

        # Set outputs
        echo "score=${SCORE}" >> "$GITHUB_OUTPUT"
        echo "grade=${GRADE}" >> "$GITHUB_OUTPUT"
        echo "badge=${BADGE_URL}" >> "$GITHUB_OUTPUT"

        # Multiline JSON output
        EOF_MARKER="EOF_$(head -c 15 /dev/urandom | base64 | tr -d '/+=')"
        {
          echo "result<<${EOF_MARKER}"
          echo "$RESULT"
          echo "${EOF_MARKER}"
        } >> "$GITHUB_OUTPUT"

        # Job Summary (always written â€” shows in Actions tab)
        {
          echo "## ${EMOJI} AI-Readiness Report"
          echo ""
          echo "| Metric | Value |"
          echo "|--------|-------|"
          echo "| **URL** | \`${INPUT_URL}\` |"
          echo "| **Score** | **${SCORE}/100** |"
          echo "| **Grade** | **${GRADE}** |"
          echo ""
          echo "![AI-Ready: ${SCORE} (${GRADE})](${BADGE_URL})"
          echo ""

          # Top recommendations from JSON
          echo "$RESULT" | node -e "
            const d = require('fs').readFileSync('/dev/stdin','utf8');
            const j = JSON.parse(d);
            const recs = j.recommendations || [];
            if (recs.length > 0) {
              console.log('### Top Recommendations');
              console.log('');
              recs.slice(0, 5).forEach((r, i) => {
                console.log(\`\${i+1}. \${r.message} *(+\${r.impact} pts)*\`);
              });
              console.log('');
            }
          "

          if [ "${INPUT_BADGE}" = "true" ]; then
            echo "### Badge Snippet"
            echo ""
            echo "\`\`\`markdown"
            echo "[![AI-Ready: ${SCORE} (${GRADE})](${BADGE_URL})](https://geo.glincker.com)"
            echo "\`\`\`"
            echo ""
          fi

          echo "---"
          echo "*Powered by [GEO Audit](https://geo.glincker.com) â€” AI-Readiness scoring for the modern web*"
        } >> "$GITHUB_STEP_SUMMARY"

        # Console output
        echo "${EMOJI} GEO Audit: ${INPUT_URL}"
        echo "   Score: ${SCORE}/100 (${GRADE})"

        # Threshold check
        if [ "${INPUT_FAIL_UNDER}" -gt 0 ] 2>/dev/null && [ "${SCORE}" -lt "${INPUT_FAIL_UNDER}" ]; then
          echo "::error::Score ${SCORE} is below threshold ${INPUT_FAIL_UNDER}"
          exit 1
        fi

    - name: Comment on PR
      if: inputs.comment == 'true' && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const score = '${{ steps.audit.outputs.score }}';
          const grade = '${{ steps.audit.outputs.grade }}';
          const badge = '${{ steps.audit.outputs.badge }}';
          const emoji = { A: 'ðŸŸ¢', B: 'ðŸŸ¢', C: 'ðŸŸ¡', D: 'ðŸŸ ', F: 'ðŸ”´' };
          const e = emoji[grade] || 'âšª';

          // Find and update existing comment (avoid spam)
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          const existing = comments.find(c =>
            c.user.type === 'Bot' && c.body.includes('AI-Readiness Report')
          );

          const body = [
            `## ${e} AI-Readiness Report`,
            '',
            `| Metric | Value |`,
            `|--------|-------|`,
            `| **URL** | \`${{ inputs.url }}\` |`,
            `| **Score** | **${score}/100** |`,
            `| **Grade** | **${grade}** |`,
            '',
            `![AI-Ready](${badge})`,
            '',
            `---`,
            `*Powered by [GEO Audit](https://geo.glincker.com)*`,
          ].join('\n');

          if (existing) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existing.id,
              body,
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });
          }
